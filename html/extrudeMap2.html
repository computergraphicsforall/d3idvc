<!DOCTYPE html>
<html>
    <head>
        <!-- Computación gráfica -->
        <!-- Jorge Victorino, Miguel Barrero-->
        <title>Documento guia para Three.js</title>
        <!--Configuracion meta-->
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

        <script type="text/javascript" src="../../grafica/three.js/build/three.js"></script>
        <script type="text/javascript" src="../../grafica/three.js/examples/js/controls/OrbitControls.js"></script>
        <script type="text/javascript" src="https://d3js.org/d3.v5.min.js"></script>
    </head>
    <body>
        <script type="text/javascript">

            let   renderer, scene, camera, light1, light2, controls, polygonUPZ;
            const PATH_UPZ_FILE = '../data/dataupz.json';
            const worldx = -74.08174939702558, worldy = 4.60971021280353;

            let dataUPZ = dataLoad(PATH_UPZ_FILE);
            dataUPZ.then(data => polygonUPZ = data)
                .then(c => initScene())
                .then(c => animate())
                .then(c => gui());

            function drawMap() {

                let map = new THREE.Group();

                for (var i = 0; i < polygonUPZ.features.length; i++) {

                    let polygonGeometry = new THREE.Geometry();
                    let nPolygons = polygonUPZ.features[i].geometry.coordinates.length;
                    let levels = true;
                    const sc = 0.0005;
                    //const deep = 0.0005 * Math.round((Math.random()*10));
                    const deep = 0.002;

                    let extrSet = {depth: deep, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: sc, bevelThickness: sc};

                    if (polygonUPZ.features[i].geometry.coordinates[0][0][0].length == undefined)
                        levels = false;

                    if (levels) {
                        let multipolygon = new THREE.Group();
                        for(let j = 0; j < nPolygons; j++){
                            let nPoints = polygonUPZ.features[i].geometry.coordinates[j][0].length;
                            let pts = [], cx = 0, cy = 0;

                            for (var k = 0; k < nPoints; k++) {

                                let lon = polygonUPZ.features[i].geometry.coordinates[j][0][k][0];
                                let lat = polygonUPZ.features[i].geometry.coordinates[j][0][k][1];
                                cx += lon;
                                cy += lat;
                                pts.push(new THREE.Vector2(lon, lat));

                            }
                            cx /= nPoints;
                            cy /= nPoints;
                            cx = (cx - worldx)/12
                            cy = (cy - worldy)/10
                            let shape = new THREE.Shape(pts);
                            let geo = new THREE.ExtrudeBufferGeometry(shape, extrSet);
                            geo.translate(cx, cy, 0);
                            let mat = new THREE.MeshPhongMaterial({color: 'white', shininess: 124});
                            let shapeMesh = new THREE.Mesh(geo, mat);

                            multipolygon.add(shapeMesh);
                        }
                        map.add(multipolygon);
                    }
                    else {
                        let nPoints = polygonUPZ.features[i].geometry.coordinates[0].length;
                        let pts = [], cx = 0, cy = 0;

                        for (let k = 0; k < nPoints; k++) {

                            let lon = polygonUPZ.features[i].geometry.coordinates[0][k][0];
                            let lat = polygonUPZ.features[i].geometry.coordinates[0][k][1];
                            cx += lon;
                            cy += lat;
                            pts.push(new THREE.Vector2(lon, lat));
                        }
                        cx /= nPoints;
                        cy /= nPoints;
                        cx = (cx - worldx)/12
                        cy = (cy - worldy)/10
                        let shape = new THREE.Shape(pts);
                        var mat = new THREE.MeshPhongMaterial({color: 'white', shininess: 124});
                        var geo = new THREE.ExtrudeBufferGeometry(shape, extrSet);
                        geo.translate(cx, cy, 0);
                        var shapeMesh = new THREE.Mesh(geo, mat);

                        map.add(shapeMesh);
                    }
                }
                scene.add(map);
            }

            function dataLoad (path) {

                if (path.endsWith('.csv') || path.endsWith('.CSV')) {

                    return d3.csv(path);
                }
                else if (path.endsWith('.json') || path.endsWith('.JSON')) {

                    return d3.json(path);
                }
            }

            function initScene() {
                scene = new THREE.Scene();
                scene.background = new THREE.Color('slategray');

                renderer = new THREE.WebGLRenderer( {antialias:true} );
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement)

                camera = new THREE.PerspectiveCamera(65, window.innerWidth/window.innerHeight, 0.01, 100);
                camera.position.set(worldx-0.1, worldy, 0.32);

                camera.up.set(0, 0, 1);

                light1 = new THREE.PointLight('cadetblue');
                light1.position.set(-70, 4, 10);

                light2 = new THREE.PointLight('plum');
                light2.position.set(-75, 8, -10);

                controls = new THREE.OrbitControls(camera, renderer.domElement)
                controls.target.set(worldx, worldy, 0);
                controls.addEventListener('change', render)
                drawMap();

                const axis = new THREE.AxesHelper(1);
                axis.position.x = worldx;
                axis.position.y = worldy;

                scene.add(axis);
                scene.add(light1)
                scene.add(light2)
                controls.update();
                window.addEventListener('resize', onWindowResize, false);
            }

            function render() {
                renderer.render(scene, camera);

            }

            function animate() {

                requestAnimationFrame(animate);
                render();
            }

            function gui() {

            }

            function onWindowResize () {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor('slategray');
                render();
            }
        </script>
    </body>
</html>