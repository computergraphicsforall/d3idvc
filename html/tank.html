<!DOCTYPE html>
<html>
    <head>
        <!-- Computación gráfica -->
        <!-- Jorge Victorino, Miguel Barrero-->
        <title>Documento guia para Three.js</title>
        <!--Configuracion meta-->
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

        <!-- Recursos basicos de three.js -->
        <!-- La ruta de estos recursos son relativos dependiendo en donde usted los tenga -->
        <script type="text/javascript" src="../../grafica/three.js/build/three.js"></script>
        <script type="text/javascript" src="../../grafica/three.js/examples/js/controls/OrbitControls.js"></script>
    </head>
    <style>
        body {
            margin: 0;
            overflow-x: hidden;
            overflow-y: hidden;
        }
    </style>
    <body>
        <script type="text/javascript">
            //http://math.hws.edu/graphicsbook/index.html Libro de computación grafica, en linea y gratis

            var renderer, scene, camera, light1, light2, controls, time = 0;
            var move_forward = false, move_backward = false, rotate_left = false, rotate_right = false;
            //initScene();
            var vtankdir = new THREE.Vector2(0, 1);
            var vtankpos = new THREE.Vector2(0, 0);



            //function initScene() {
                scene = new THREE.Scene();
                scene.background = new THREE.Color('slategray');

                renderer = new THREE.WebGLRenderer( {antialias:true} );
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement)

                camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
                camera.position.set(0, 30, -50);
                camera.lookAt(0,0,0);
                camera.up.set(0, 1, 0);

                light1 = new THREE.PointLight('white');
                light1.position.set(90, 100, 0);

                light2 = new THREE.PointLight('white');
                light2.position.set(-90, 100, 0);

                controls = new THREE.OrbitControls(camera, renderer.domElement)
                controls.addEventListener('change', render)
                controls.enableKeys = false;

                const groundGeometry = new THREE.PlaneBufferGeometry(50, 50);
                const groundMaterial = new THREE.MeshPhongMaterial({color: 0xCC8866});
                const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
                groundMesh.rotation.x = Math.PI * -.5;
                groundMesh.receiveShadow = true;
                scene.add(groundMesh);

                const carWidth  = 4;
                const carHeight = 1;
                const carLength = 8;

                const tank = new THREE.Object3D();
                scene.add(tank);

                const bodyGeometry = new THREE.BoxBufferGeometry(carWidth, carHeight, carLength);
                const bodyMaterial = new THREE.MeshPhongMaterial({color: 0x6688AA});
                const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
                bodyMesh.position.y = 1.4;
                bodyMesh.castShadow = true;
                tank.add(bodyMesh);

                const wheelRadius = 1;
                const wheelThickness = .5;
                const wheelSegments = 6;
                const wheelGeometry = new THREE.CylinderBufferGeometry(
                    wheelRadius,     // top radius
                    wheelRadius,     // bottom radius
                    wheelThickness,  // height of cylinder
                    wheelSegments);
                const wheelMaterial = new THREE.MeshPhongMaterial({color: 0x888888});
                const wheelPositions = [
                    [-carWidth / 2 - wheelThickness / 2, -carHeight / 2,  carLength / 3],
                    [ carWidth / 2 + wheelThickness / 2, -carHeight / 2,  carLength / 3],
                    [-carWidth / 2 - wheelThickness / 2, -carHeight / 2, 0],
                    [ carWidth / 2 + wheelThickness / 2, -carHeight / 2, 0],
                    [-carWidth / 2 - wheelThickness / 2, -carHeight / 2, -carLength / 3],
                    [ carWidth / 2 + wheelThickness / 2, -carHeight / 2, -carLength / 3],
                ];
                const wheelMeshes = wheelPositions.map((position) => {
                    const mesh = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    mesh.position.set(...position);
                    mesh.rotation.z = Math.PI * .5;
                    mesh.castShadow = true;
                    bodyMesh.add(mesh);
                    return mesh;
                });

                const domeRadius = 2;
                const domeWidthSubdivisions = 12;
                const domeHeightSubdivisions = 12;
                const domePhiStart = 0;
                const domePhiEnd = Math.PI * 2;
                const domeThetaStart = 0;
                const domeThetaEnd = Math.PI * .5;
                const domeGeometry = new THREE.SphereBufferGeometry(
                    domeRadius, domeWidthSubdivisions, domeHeightSubdivisions,
                    domePhiStart, domePhiEnd, domeThetaStart, domeThetaEnd);
                const domeMesh = new THREE.Mesh(domeGeometry, bodyMaterial);
                domeMesh.castShadow = true;
                bodyMesh.add(domeMesh);
                domeMesh.position.y = .5;

                const turretWidth = .1;
                const turretHeight = .1;
                const turretLength = carLength * .75 * .2;
                const turretGeometry = new THREE.BoxBufferGeometry(
                    turretWidth, turretHeight, turretLength);
                const turretMesh = new THREE.Mesh(turretGeometry, bodyMaterial);
                const turretPivot = new THREE.Object3D();
                turretMesh.castShadow = true;
                turretPivot.scale.set(5, 5, 5);
                turretPivot.position.y = .5;
                turretMesh.position.z = turretLength * .5;
                turretPivot.add(turretMesh);
                bodyMesh.add(turretPivot);

                const targetGeometry = new THREE.SphereBufferGeometry(.5, 6, 3);
                const targetMaterial = new THREE.MeshPhongMaterial({color: 0x00FF00, flatShading: true});
                const targetMesh = new THREE.Mesh(targetGeometry, targetMaterial);
                const targetOrbit = new THREE.Object3D();
                const targetElevation = new THREE.Object3D();
                const targetBob = new THREE.Object3D();
                targetMesh.castShadow = true;
                scene.add(targetOrbit);
                targetOrbit.add(targetElevation);
                targetElevation.position.z = carLength * 2;
                targetElevation.position.y = 8;
                targetElevation.add(targetBob);
                targetBob.add(targetMesh);

                const axis = new THREE.AxesHelper(2);

                scene.add(axis);
                scene.add(light1)
                scene.add(light2)

                window.addEventListener('resize', onWindowResize, false);
                document.addEventListener( 'keydown', onKeyDown, false );
                document.addEventListener( 'keyup', onKeyUp, false );

            function render() {
                time += 1;

                if(move_forward || move_backward){

                }
                if(move_forward){
                    vtankpos.x += vtankdir.x*0.1;
                    vtankpos.y += vtankdir.y*0.1;
                    tank.position.set(vtankpos.x, 0, vtankpos.y);
                    wheelMeshes.forEach((obj) => {
                        obj.rotation.x = time * 0.1;
                    });
                }
                if(move_backward){
                    vtankpos.x -= vtankdir.x*0.1;
                    vtankpos.y -= vtankdir.y*0.1;
                    tank.position.set(vtankpos.x, 0, vtankpos.y);
                    wheelMeshes.forEach((obj) => {
                        obj.rotation.x = -time * 0.1;
                    });
                }
                if(rotate_left){
                    vtankdir.rotateAround(new THREE.Vector2(0,0), -Math.PI/360);
                    tank.rotateY(Math.PI/360)
                }
                if(rotate_right){
                    vtankdir.rotateAround(new THREE.Vector2(0,0), Math.PI/360);
                    tank.rotateY(-Math.PI/360)
                }

                renderer.render(scene, camera)
            }

            function onWindowResize () {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor('slategray');
                controls.update();
                render();
            }
            function animate() {

                requestAnimationFrame(animate);
                render();
            }

            function gui() {

            }

            function onKeyDown(event){
                console.log(event.keyCode)
                switch(event.keyCode){
                    case 38: move_forward = true; break;
                    case 40: move_backward = true; break;
                    case 37: rotate_left = true; break;
                    case 39: rotate_right = true; break;
                    case 80: console.log(vtankdir); break;
                }
            };

            function onKeyUp(event){
                switch(event.keyCode){
                    case 38: move_forward  = false; break;
                    case 40: move_backward = false; break;
                    case 37: rotate_left   = false; break;
                    case 39: rotate_right  = false; break;
                }
            }


            animate();
            gui();

        </script>
    </body>
</html>



